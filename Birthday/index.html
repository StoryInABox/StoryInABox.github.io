<!DOCTYPE html>
<html lang="en">
	<head>
	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<style>
			body {
				background-color: #eee;
				position: absolute;
			width: auto;
			height: auto;
			}
			#info {
				color: #222;
			}
			a {
				color: #00f
			}
			#button {
				position: absolute;
				bottom: -20px;
				right: 20px;

			}
			#music{
				position: absolute;
				width: 100%;
			}

			.loading{
				position: absolute;
				border:none;
				top: 0px;
				height:100%;
				width:100%;
				opacity:1;
				background-color: transparent;
				transition: 1s;
				display: block;
				z-index: 3;
				
			}
			.loadingText{
				position: absolute;
				
				width: 120px;
				margin-left: -60px;
				text-align: center;
				top: 60%;
				left: 50%;
				color:white;
				
			}
			.loadingcircle{
				position: absolute;
				top: 50%;
				left: 50%;
				margin-left: -38px;
				margin-top: -38px;
				border: 8px solid #f3f3f3; /* Light grey */
				border-top: 8px solid #E6007E; /* Blue */
				border-radius: 50%;
				width: 60px;
				height: 60px;
				animation: spin 2s linear infinite;
			}
			@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
			}

			.loading.checked{

				opacity:0;
				z-index: -2;

			}


		</style>
	</head>

	<body style='margin : 0px; overflow: hidden;'>
		<div class="loading">
            <div class="loadingcircle"></div>
            <div class="loadingText">lade 3D-Model...</div>
            
        </div>

		<a id="link" rel="ar"  href="Download/Till_Dance_Finial.reality" download="Till_Dance_Finial.reality">
			<img id="button"  height="100" width="100" src="button.png">
		</a>
		<audio id="music" controls preload muted>
			<source src="happy.mp3" type="audio/mpeg">
		</audio>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { OrbitControls } from './controls/OrbitControls.js';
			import { RoomEnvironment } from './js/RoomEnvironment.js';

			import { GLTFLoader } from './js/GLTFLoader.js';
			//import { USDZExporter } from './js/USDZExporter.js';
			import { RGBELoader } from './js/RGBELoader.js';
	

			let camera, scene, renderer, mixer, clock;
			let pmremGenerator;
			let aktuelleAnimation;

			let loadingStautus =  new THREE.LoadingManager();

			let music = document.getElementById("music");
			init();
			animate();

			function init() {

				clock = new THREE.Clock();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 20 );
				camera.position.set( .6, 0.25, 2 );

				

				scene = new THREE.Scene();




				pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();
				
				


				new RGBELoader()
					.setDataType( THREE.UnsignedByteType )
					.setPath( 'textures/' )
					.load( 'brown_photostudio_01_1k.hdr', function ( texture ) {

						const envMap = pmremGenerator.fromEquirectangular( texture ).texture;

						//scene.background = envMap;
						scene.background = new THREE.Color( 0x222222 );
						//scene.environment = new THREE.Color( 0x2ffffff );
						scene.environment = envMap;
						//scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 1 ).texture;


					texture.dispose();
					pmremGenerator.dispose();

				});


				loadingStautus.onStart = function ( url, itemsLoaded, itemsTotal ) {

				console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
				//document.getElementsByClassName("loading")[0].classList.toggle("checked");

				};

				loadingStautus.onLoad = function ( ) {

				console.log( 'Loading complete!');
				//let loadingCanvas = document.getElementsByClassName("loading");
                document.getElementsByClassName("loading")[0].classList.toggle("checked");
				//console.log(loadingCanvas[0].classList.toggle("checked"))
				//console.log(document.getElementById("music"));
				
				//console.log(music.src)
				music.autoplay = true;
				music.load();


				};
				

				
				music.oncanplaythrough = function() {
   				 
					
					
					
					
					//music.play();
					console.log(document.getElementById("music"));
					music.muted= false;
					//music.play = true
				};

				const loader = new GLTFLoader(loadingStautus).setPath( 'models/' );
				loader.load( 'Till_pose_final.gltf', async function ( gltf ) {
                    gltf.scene.position.set( 0, 0, 0 );
                    gltf.scene.scale.set( .25, .25, .25 );
                    
					

					const shadowMesh = createSpotShadowMesh(loadingStautus);
					shadowMesh.position.y = - 0;
					shadowMesh.position.z = 0;
					shadowMesh.scale.setScalar( 1 );
					scene.add( shadowMesh );


					mixer = new THREE.AnimationMixer( gltf.scene );
						for (let i=0; i<gltf.scene.children.length; i++) {	

							if (typeof gltf.animations[i] !== "undefined"){
								//console.log(gltf.animations[i])
								mixer.clipAction( gltf.animations[i] ).play();
							}
							
						}

						gltf.scene.traverse((child) => {	
                       if (child.isMesh) {
						
						child.material.side = THREE.DoubleSide;
						//child.material.emissiveMap = child.material.map;
						//child.material.emissiveIntensity = 100 ;
						//child.frustumCulled = false;
						
						child.material.receiveShadow = false;
						child.material.castShadow = false;

						console.log(child)
						}			
                    });

					requestAnimationFrame(animate);
					scene.add( gltf.scene );

					// USDZ
/*
					const exporter = new USDZExporter();
					const arraybuffer = await exporter.parse( gltf.scene );
					const blob = new Blob( [ arraybuffer ], { type: 'application/octet-stream' } );

					const link = document.getElementById( 'link' );
					link.href = URL.createObjectURL( blob );
*/
				} );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = .35;
				controls.maxDistance = 2.5;
				controls.target.set( -.1, .25, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function createSpotShadowMesh(loadingStautus) {

				const canvas = document.createElement( 'canvas' );
				canvas.width = 128;
				canvas.height = 128;

				const context = canvas.getContext( '2d' );
				const gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
				gradient.addColorStop( 0.1, 'rgba(130,130,130,1)' );
				gradient.addColorStop( 1, 'rgba(255,255,255,1)' );

				context.fillStyle = gradient;
				context.fillRect( 0, 0, canvas.width, canvas.height );

				const shadowTexture = new THREE.CanvasTexture( canvas );

				const geometry = new THREE.PlaneGeometry();
				const material = new THREE.MeshBasicMaterial( {
					map: shadowTexture, blending: THREE.MultiplyBlending, toneMapped: false
				} );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.rotation.x = - Math.PI / 2;

				return mesh;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				animate();

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

			function animate() {

				aktuelleAnimation = requestAnimationFrame(animate);
				//deltaTime = clock.getDelta();
				const delta = clock.getDelta();
				//totalTime += deltaTime;

				if (typeof mixer !== 'undefined'){
					//console.log(mixer)
					mixer.update(delta);


				}

				render();

			}			


			
		</script>

	</body>
</html>
