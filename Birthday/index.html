<!DOCTYPE html>
<html lang="en">
	<head>
	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<style>
			body {
				background-color: #eee;
				position: absolute;
			width: auto;
			height: auto;
			}
			#info {
				color: #222;
			}
			a {
				color: #00f
			}
			#button {
				position: absolute;
				bottom: 15px;
				left: calc(50% - 40px);

			}
		</style>
	</head>

	<body style='margin : 0px; overflow: hidden;'>
		

		<a id="link" rel="ar" href="" download="asset.usdz">
			<img id="button" width="100" src="arkit.png">
		</a>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { OrbitControls } from './controls/OrbitControls.js';
			import { RoomEnvironment } from './js/RoomEnvironment.js';

			import { GLTFLoader } from './js/GLTFLoader.js';
			import { USDZExporter } from './js/USDZExporter.js';
			import { RGBELoader } from './js/RGBELoader.js';
	

			let camera, scene, renderer, mixer, clock;
			let pmremGenerator;
			let aktuelleAnimation;

			init();
			animate();

			function init() {

				clock = new THREE.Clock();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
				camera.position.set( 0, 0.25, 0 );

				

				scene = new THREE.Scene();

				pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();
						
				new RGBELoader()
					.setDataType( THREE.UnsignedByteType )
					.setPath( 'textures/' )
					.load( 'brown_photostudio_01_1k.hdr', function ( texture ) {

						const envMap = pmremGenerator.fromEquirectangular( texture ).texture;

						//scene.background = envMap;
						scene.background = new THREE.Color( 0xc5c5c5 );
						//scene.environment = new THREE.Color( 0x2ffffff );
						scene.environment = envMap;
						//scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 1 ).texture;


					texture.dispose();
					pmremGenerator.dispose();

				});
				const loader = new GLTFLoader().setPath( 'models/' );
				loader.load( 'Till.gltf', async function ( gltf ) {
                    gltf.scene.position.set( 0, 0, 0 );
                    gltf.scene.scale.set( .25, .25, .25 );
                    
					

					const shadowMesh = createSpotShadowMesh();
					shadowMesh.position.y = - 0;
					shadowMesh.position.z = 0;
					shadowMesh.scale.setScalar( 1 );
					scene.add( shadowMesh );


					mixer = new THREE.AnimationMixer( gltf.scene );
						for (let i=0; i<gltf.scene.children.length; i++) {	

							if (typeof gltf.animations[i] !== "undefined"){
								//console.log(gltf.animations[i])
								mixer.clipAction( gltf.animations[i] ).play();
							}
							
						}

						gltf.scene.traverse((child) => {	
                       if (child.isMesh) {
						
						child.material.side = THREE.DoubleSide;
						//child.material.emissiveMap = child.material.map;
						//child.material.emissiveIntensity = 100 ;
						//child.frustumCulled = false;
						
						child.material.receiveShadow = false;
						child.material.castShadow = false;

						console.log(child)
						}			
                    });

					requestAnimationFrame(animate);
					scene.add( gltf.scene );

					// USDZ

					const exporter = new USDZExporter();
					const arraybuffer = await exporter.parse( gltf.scene );
					const blob = new Blob( [ arraybuffer ], { type: 'application/octet-stream' } );

					const link = document.getElementById( 'link' );
					link.href = URL.createObjectURL( blob );

				} );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.target.set( 0, .25, 0 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );

			}

			function createSpotShadowMesh() {

				const canvas = document.createElement( 'canvas' );
				canvas.width = 128;
				canvas.height = 128;

				const context = canvas.getContext( '2d' );
				const gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
				gradient.addColorStop( 0.1, 'rgba(130,130,130,1)' );
				gradient.addColorStop( 1, 'rgba(255,255,255,1)' );

				context.fillStyle = gradient;
				context.fillRect( 0, 0, canvas.width, canvas.height );

				const shadowTexture = new THREE.CanvasTexture( canvas );

				const geometry = new THREE.PlaneGeometry();
				const material = new THREE.MeshBasicMaterial( {
					map: shadowTexture, blending: THREE.MultiplyBlending, toneMapped: false
				} );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.rotation.x = - Math.PI / 2;

				return mesh;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				animate();

			}

			//

			function render() {

				renderer.render( scene, camera );

			}

			function animate() {

				aktuelleAnimation = requestAnimationFrame(animate);
				//deltaTime = clock.getDelta();
				const delta = clock.getDelta();
				//totalTime += deltaTime;

				if (typeof mixer !== 'undefined'){
					//console.log(mixer)
					mixer.update(delta);


				}

				render();

			}			

		</script>

	</body>
</html>
