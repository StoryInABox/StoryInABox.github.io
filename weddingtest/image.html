<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Hello, AR Cube!</title>
	<!-- include three.js library -->
	<script src='js/three.js'></script>
	<!-- include jsartookit -->

	<!-- include threex.artoolkit -->

    <!-- 

	<script src="threex/threex-artoolkitsource.js"></script>
	<script src="threex/threex-artoolkitcontext.js"></script>
	<script src="threex/threex-arbasecontrols.js"></script>
	<script src="threex/threex-armarkercontrols.js"></script>

    -->

    <script src="threex/ar-threex.js"></script>
	<style>
		body {
			position: absolute;
			width: auto;
			height: auto;
		}
		
	</style>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

    

<!-- 
  Example created by Lee Stemkoski: https://github.com/stemkoski
  Based on the AR.js library and examples created by Jerome Etienne: https://github.com/jeromeetienne/AR.js/
-->

<script type="module">

import * as THREE from './build/three.module.js';

import { GLTFLoader } from './js/GLTFLoader.js';
import { DRACOLoader } from './js/DRACOLoader.js';
import { RGBELoader } from './js/RGBELoader.js';
	
let mixer, controls, pmremGenerator, RGBE, envMap, dracoLoader, loader, model,aktuelleAnimation;

var scene, camera, renderer, clock, deltaTime, totalTime;

var arToolkitSource, arToolkitContext;

var markerRoot1, markerRoot2;

var mesh1;

initialize();
animate();

function initialize()
{
	scene = new THREE.Scene();
/*
	let ambientLight = new THREE.AmbientLight( 0xcccccc, 1 );
	scene.add( ambientLight );
	
	let light = new THREE.PointLight( 0xff0000, 1,2000);
	light.position.set( 0, -50, 0 );
	scene.add( light );
*/
	camera = new THREE.Camera();
	scene.add(camera);

	renderer = new THREE.WebGLRenderer({
		antialias : true,
		logarithmicDepthBuffer: true, 
		//preserveDrawingBuffer:false,
		alpha: true
		
	});
	renderer.setPixelRatio(window.devicePixelRatio*2);
	renderer.setClearColor(new THREE.Color('lightgrey'), 0)
	renderer.setSize( window.innerWidth, window.innerHeight );
	//renderer.setPixelRatio( window.devicePixelRatio );
	renderer.domElement.style.position = 'absolute'
	renderer.domElement.style.top = '0px'
	renderer.domElement.style.left = '0px'
	//renderer.autoClearDepth = true;

	document.body.appendChild( renderer.domElement );

	clock = new THREE.Clock();
	deltaTime = 0;
	totalTime = 0;
	



	////////////////////////////////////////////////////////////
	// setup arToolkitSource
	////////////////////////////////////////////////////////////

	arToolkitSource = new THREEx.ArToolkitSource({
		sourceType : 'webcam',
		
		//sourceWidth:640,sourceHeight:480,displayWidth:window.innerWidth,displayHeight:window.innerHeight
	});

	function onResize()
	{
		//arToolkitSource.onResize()	
        arToolkitSource.onResizeElement()
		console.log("test")
		//arToolkitSource.copySizeTo(renderer.domElement)	
        arToolkitSource.copyElementSizeTo(renderer.domElement)	
		if ( arToolkitContext.arController !== null )
		{
			
			//arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
            arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)	
		}	
	}

	arToolkitSource.init(function onReady(){
		setTimeout(function() {
                onResize()
            }, 50);
		//onResize();
		

		
	});
	
	// handle resize event
	window.addEventListener('resize', function(){
		onResize();
		//console.log("test")
		
	});
	
	////////////////////////////////////////////////////////////
	// setup arToolkitContext
	////////////////////////////////////////////////////////////	

	// create atToolkitContext
	arToolkitContext = new THREEx.ArToolkitContext({
		cameraParametersUrl: 'data/camera_para.dat',
		detectionMode: 'mono',
		maxDetectionRate: 60
		
	});
	
	// copy projection matrix to camera when initialization complete
	arToolkitContext.init( function onCompleted(){
		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		
	});

	////////////////////////////////////////////////////////////
	// setup markerRoots
	////////////////////////////////////////////////////////////

	// build markerControls
	markerRoot1 = new THREE.Group();
	scene.add(markerRoot1);
	let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, {
		//type: 'pattern', patternUrl: "data/hiro.patt",

        type : 'nft', descriptorsUrl : './weddingtest/data/dingd/testonew',
		smooth : true,
	
		smoothCount: 20,
		smoothThreshold: .1,
		smoothTolerance: 2
        //changeMatrixMode: 'cameraTransformMatrix'
	})
	
/*	

	let geometry1	= new THREE.BoxGeometry(20,20,20);
	let material1	= new THREE.MeshNormalMaterial({
		transparent: true,
		opacity: 1,
		side: THREE.DoubleSide
	}); 

	mesh1 = new THREE.Mesh( geometry1, material1 );
	//mesh1.position.set(10, -5, -10);
	markerRoot1.add( mesh1 );
	
*/
	

				pmremGenerator = new THREE.PMREMGenerator( renderer );
				pmremGenerator.compileEquirectangularShader();
						
				new RGBELoader()
					.setDataType( THREE.UnsignedByteType )
					.setPath( 'textures/' )
					.load( 'studio_small_08_1k.hdr', function ( texture ) {

						const envMap = pmremGenerator.fromEquirectangular( texture ).texture;

						//scene.background = envMap;
						//scene.background = new THREE.Color( 0x2ffffff );
						scene.environment = envMap;
					


					texture.dispose();
					pmremGenerator.dispose();

				});
			dracoLoader = new DRACOLoader();
				dracoLoader.setDecoderPath( 'js/draco/' );

				loader = new GLTFLoader();
				loader.setDRACOLoader( dracoLoader );
				loader.load( './model/1.gltf',  function ( gltf ) {
                    //gltf.scene.position.set( 0, 0, -5 );
					//gltf.scene.rotation.set( 0.1, 0, 0 );
                    gltf.scene.scale.set( 10,10,10 );
                    

					gltf.scene.traverse((child) => {
                        //if (child.isMesh) child.material = material1; // a material i created in the code earlier
						//if (child.isMesh) child.material =gltf.scene.children[0].children[0].material
                    });
                 
					
						mixer = new THREE.AnimationMixer( gltf.scene );
			
					

					
					mixer.clipAction( gltf.animations[0] ).play();
				
					

					//console.log(mixer.clipAction( gltf.animations[0] ) )
					//scene.add( gltf.scene );
					
					markerRoot1.add( gltf.scene  );
					requestAnimationFrame(animate);
					//animate();
					
					//position.getPositionFromMatrix( markerRoot1.matrixWorld );
					console.log(gltf.scene.children[0].children[0])
					//console.log(position.getPositionFromMatrix( markerRoot1.matrixWorld ))
				} );








	console.log(document)
	console.log(scene)
	console.log(markerControls1.context)
	console.log(camera)
	
}


function update()
{
	// update artoolkit on every frame
	if ( arToolkitSource.ready !== false )
	{
		arToolkitContext.update( arToolkitSource.domElement );	
	}
}


function render()
{
	renderer.render( scene, camera );
	
	//console.log(arToolkitContext.getProjectionMatrix().elements )
	//console.log(scene.scale)
	//markerRoot1.children[0].scale.set(10,10,10)
	
	//console.log(markerRoot1.children[0].scale)
	
	//var position = new THREE.Vector3();
	/*
	scene.children[2].children[0].position.x =position.getPositionFromMatrix( markerRoot1.matrixWorld ).x
	scene.children[2].children[0].position.y =position.getPositionFromMatrix( markerRoot1.matrixWorld ).y
	scene.children[2].children[0].position.z =position.getPositionFromMatrix( markerRoot1.matrixWorld ).z
	scene.children[2].children[0].scale.x = 10
	scene.children[2].children[0].scale.y = 10
	scene.children[2].children[0].scale.z = 10
	*/
	//console.log(scene.children[2].children[0].position.x)
	//console.log(position.getPositionFromMatrix( markerRoot1.matrixWorld ).x)
	//console.log(arToolkitContext.arController.marker_transform_mat)
}


function animate()
{
	aktuelleAnimation = requestAnimationFrame(animate);
	//deltaTime = clock.getDelta();
	const delta = clock.getDelta();
	//totalTime += deltaTime;

	if (typeof mixer !== 'undefined'){
		//console.log(mixer)
		mixer.update(delta);


	}
//console.log(scene.children[1].children[0].children[1].geometry.attributes.uv.normalized)
	update();
	render();
	
	
}

</script>

</body>
</html>